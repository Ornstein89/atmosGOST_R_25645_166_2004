#include "atmosGOST_R_25645_166_2004.h"
#define _USE_MATH_DEFINES
#include <iostream>
#include <cmath>
//#include <math.h>
#define PARAMETERS_CHECK_ON // включение проверки входных параметров функций, снижает производительность но облегчает поиск ошибок

// Таблицы

double const a_low_table[8][7] = {
	{	120.0	,	120.0	,	120.0,	120.0,	120.0,	120	,	120}, // ah
	{	26.8629	,	27.4598	,	28.6395,	29.6418,	30.1671,	29.7578,	30.7854}, // a0
	{	-0.451674	,	-0.463668,	-0.490987,	-0.514957,	-0.527837,	-0.517915,	-0.545695}, // a1
	{	0.00290397	,	0.002974,	0.00320649,	0.00341926,	0.00353211,	0.00342699,	0.00370328}, // a2
	{	-1.06953E-05	,	-0.000010753,	-0.000011681,	-1.25785E-05,	-1.30227E-05,	-1.24137E-05,	-1.37072E-05}, // a3
	{	2.21598E-08	,	2.17059E-08,	2.36847E-08	,	2.5727E-08,	2.66455E-08,	2.48209E-08,	2.80614E-08	}, // a4
	{	-2.42941E-11	,	-2.30249E-11,	-2.51809E-11,	-2.75874E-11,	-2.85432E-11,	-2.58413E-11,	-3.00184E-11}, // a5
	{	1.09926E-14	,	1.00123E-14,	1.09536E-14,	1.21091E-14,	1.25009E-14,	1.09383E-14,	1.31142E-14	}}; // a6

double const a_high_table[8][7] = {
	{500,	500,	500,	500,	500,	500,	500}, // ah
	{17.8781,	-2.54909,	-13.9599,	-23.3079,	-14.7264,	-4.912,	-5.40952}, // a0
	{-0.132025,	0.0140064,	0.0844951,	0.135141,	0.0713256,	0.0108326,	0.00550749}, // a1
	{0.000227717,	-0.00016946,	-0.000328875,	-0.000420802,	-0.000228015,	-8.10546E-05,	-3.78851E-05}, // a2
	{-2.2543E-07,	3.27196E-07,	5.05918E-07,	5.73717E-07,	2.8487E-07,	1.15712E-07,	2.4808E-08}, // a3
	{1.33574E-10,	-2.8763E-10,	-3.92299E-10,	-4.03238E-10,	-1.74383E-10,	-8.13296E-11,	4.92183E-12}, // a4
	{-4.50458E-14,	1.22625E-13,	1.52279E-13,	1.42846E-13,	5.08071E-14,	3.04913E-14,	-8.65011E-15}, // a5
	{6.72086E-18,	-2.05736E-17,	-2.35576E-17,	-2.01726E-17,	-5.34955E-18,	-4.94989E-18,	1.9849E-18} }; // a6

double const b_low_table[6][7] = {
	{	120	,	120	,	120	,	120	,	120	,	120	,	120	}, // bh
	{	0.0687894	,	0.15073	,	0.0479451	,	0.0223448	,	-0.00326391	,	-0.0514749	,	-0.107255	}, // b0
	{	-0.00284077	,	-0.00400889	,	-0.00239453	,	-0.0019798	,	-0.00159869	,	-0.000921059	,	-0.000174343	}, // b1
	{	1.83922E-05	,	2.43937E-05	,	1.70335E-05	,	1.54101E-05	,	1.40443E-05	,	1.15147E-05	,	9.02759E-06	}, // b2
	{	9.19605E-09	,	-9.92772E-09	,	-1.31626E-09	,	-2.3543E-09	,	-3.02287E-09	,	-1.22901E-09	,	-3.16512E-10	}, // b3
	{	-4.16873E-11	,	-1.82239E-11	,	-1.74032E-11	,	-1.24994E-11	,	-9.2016E-12	,	-8.13104E-12	,	-6.14E-12	} }; // b4

double const b_high_table[6][7] = {
	{600,	660,	760,	800,	860,	900,	1000}, // bh
	{23.1584,	33.2732,	39.1961,	43.2469,	49.5738,	11.278,	-52.6184}, // b0
	{-0.0802147,	-0.111099,	-0.12352,	-0.126973,	-0.138613,	0.00143478,	0.214689}, // b1
	{0.000105824,	0.000141421,	0.000149015,	0.000142637,	0.000147851,	-3.69846E-05,	-0.000294882}, // b2
	{-6.15036E-08,	-7.94952E-08,	-7.9705E-08,	-7.09985E-08,	-6.96361E-08,	3.58318E-08,	1.71171E-07}, // b3
	{1.32453E-11,	1.65836E-11,	1.58772E-11,	1.31646E-11,	1.21595E-11,	-9.91225E-12,	-3.60582E-11} }; // b4

double const c_low_table[6][7] = {
	{	120	,	120	,	120	,	120	,	120	,	120	,	120	}, // ch
	{	-1.04825	,	-0.93106	,	-0.820867	,	-0.744047	,	-0.722471	,	-0.687482	,	-0.739984	}, // c0
	{	0.0166305	,	0.0141537	,	0.0119916	,	0.0104743	,	0.00980317	,	0.00916594	,	0.00952854	}, // c1
	{	-9.24263E-05	,	-7.29862E-05	,	-5.79835E-05	,	-4.78544E-05	,	-4.25245E-05	,	-3.80932E-05	,	-3.62727E-05	}, // c2
	{	2.72382E-07	,	2.00294E-07	,	1.50707E-07	,	1.18513E-07	,	9.95544E-08	,	8.51275E-08	,	7.3887E-08	}, // c3
	{	-2.41355E-10	,	-1.62006E-10	,	-1.13026E-10	,	-8.31498E-11	,	-6.55175E-11	,	-5.29972E-11	,	-4.23907E-11	} }; // c4

double const c_high_table[6][7] = {
	{640,	700,	760,	820,	860,	920,	980}, // ch
	{50.5034,	61.624,	53.2623,	18.2236,	-31.8442,	-48.7208,	-147.859}, // c0
	{-0.170541,	-0.192967,	-0.144342,	-0.00840024,	0.168327,	0.222996,	0.531652}, // c1
	{0.000217232,	0.000228061,	0.00014659,	-0.0000388,	-0.000262603,	-0.000321884,	-67.1937}, // c2
	{-1.21902E-07,	-1.18715E-07,	-6.46443E-08,	4.31384E-08,	1.65454E-07,	1.91495E-07,	3.64787E-07}, // c3
	{2.54037E-11,	2.29638E-11,	1.04227E-11,	-1.23832E-11,	-3.69355E-11,	-4.08067E-11,	-7.26268E-11} }; // c4

double const n_low_table[3][7] = {
	{	2.058	,	2.058	,	2.058	,	2.058	,	2.058	,	2.058	,	2.058	}, // n0
	{	0.005887	,	0.005887	,	0.005887	,	0.005887	,	0.005887	,	0.005887	,	0.005887	}, // n1
	{	-0.000004012	,	-0.000004012	,	-0.000004012	,	-0.000004012	,	-0.000004012	,	-0.000004012	,	-0.000004012	} };  // n2

double const n_high_table[3][7] = {
	{2.058,	2.058,	2.058,	2.058,	2.058,	2.058,	2.058}, // n0
	{0.005887,	0.005887,	0.005887,	0.005887,	0.005887,	0.005887,	0.005887}, // n1
	{-0.000004012,	-0.000004012,	-0.000004012,	-0.000004012,	-0.000004012,	-0.000004012,	-0.000004012}}; // n2

double const phi1_low_table[7] = {
	0.5411,	0.5515,	0.5585,	0.5585,	0.5585,	0.5585,	0.5585}; // phi1

double const phi1_high_table[7] = {
	0.5411,	0.5515,	0.5585,	0.5585,	0.5585,	0.5585,	0.5585}; // phi1

double const d_low_table[6][7] = {
	{	120	,	120	,	120	,	120	,	120	,	120	,	120	}, // dh
	{	-0.351899	,	-0.047813	,	0.20981	,	0.265174	,	0.23047	,	0.170074	,	0.088141	}, // d0
	{	0.00577056	,	0.00380813	,	0.00262881	,	0.00275836	,	0.00338331	,	0.00406131	,	0.00468253	}, // d1
	{	9.95819E-07	,	4.22771E-06	,	4.24379E-06	,	2.08668E-06	,	-5.52305E-07	,	-2.82114E-06	,	-4.24609E-06	}, // d2
	{	-7.25324E-09	,	-8.66826E-09	,	-6.67328E-09	,	-3.69543E-09	,	-8.23607E-10	,	1.38369E-09	,	2.53509E-09	}, // d3
	{	2.9759E-12	,	3.06712E-12	,	2.13496E-12	,	1.11862E-12	,	2.21349E-13	,	-4.27908E-13	,	-7.29031E-13	} }; // d4

double const d_high_table[6][7] = {
	{1500,	1500,	1500,	1500,	1500,	1500,	1500}, // dh
	{-0.351899,	-0.047813,	0.20981,	0.265174,	0.23047,	0.170074,	0.088141}, // d0
	{0.00577056,	0.00380813,	0.00262881,	0.00275836,	0.00338331,	0.00406131,	0.00468253}, // d1
	{9.95819E-07,	4.22771E-06,	4.24379E-06,	2.08668E-06,	-5.52305E-07,	-2.82114E-06,	-4.24609E-06}, // d2
	{-7.25324E-09,	-8.66826E-09,	-6.67328E-09,	-3.69543E-09,	-8.23607E-10,	1.38369E-09,	2.53509E-09}, // d3
	{2.9759E-12,	3.06712E-12,	2.13496E-12,	1.11862E-12,	2.21349E-13,	-4.27908E-13,	-7.29031E-13} }; // d4

double const e_low_table[10][7] = {
	{	120	,	120	,	120	,	120	,	120	,	120	,	120	}, // eh
	{	-0.731596	,	-0.752175	,	-0.570476	,	-0.949573	,	-0.967598	,	-1.02278	,	-0.757903	},  // e0
	{	0.00597345	,	0.00565925	,	0.00295802	,	0.00813121	,	0.00841991	,	0.00923633	,	0.00606068	}, // e1
	{	-5.82037E-06	,	1.8082E-06	,	1.68896E-05	,	-3.87813E-06	,	-0.000003585	,	-6.10128E-06	,	7.85296E-06	}, // e2
	{	6.84634E-08	,	3.33822E-08	,	-4.7475E-09	,	2.37694E-08	,	1.74801E-08	,	1.78211E-08	,	-9.74891E-09	}, // e3
	{	-9.50483E-11	,	-5.13965E-11	,	-1.72711E-11	,	-2.77469E-11	,	-1.96221E-11	,	-1.70073E-11	,	1.58377E-12	}, // e4
	{	-0.2067	,	-0.16971	,	-0.14671	,	-0.1315	,	-0.120916	,	-0.11363	,	-0.10444	}, // e5
	{	0.097533	,	0.07983	,	0.068808	,	0.061603	,	0.056538	,	0.053178	,	0.048551	}, // e6
	{	-0.011817	,	-0.0094393	,	-0.0079836	,	-0.0070866	,	-0.0064324	,	-0.0060436	,	-0.0053567	}, // e7
	{	0.0016145	,	0.0012622	,	0.0010535	,	0.00092813	,	0.00083723	,	0.00077982	,	0.00068809	} }; // e8

double const e_high_table[10][7] = {
	{600,	700,	780,	800,	800,	900,	760}, // eh
	{38.6199,	51.249,	68.4746,	58.422,	7.20188,	21.5948,	-88.4076}, // e0
	{-0.132147,	-0.167373,	-0.215659,	-0.166664,	0.0216109,	-0.0202239,	0.338518}, // e1
	{0.000175411,	0.000211832,	0.000262273,	0.000185486,	-6.52882E-05,	-1.72029E-05,	-0.000445581}, // e2
	{-1.02417E-07,	-1.18221E-07,	-1.40972E-07,	-9.12345E-08,	5.37077E-08,	2.83017E-08,	2.51729E-07}, // e3
	{2.21446E-11,	2.45055E-11,	2.82285E-11,	1.67118E-11,	-1.4095E-11,	-8.94486E-12,	-5.203E-11}, // e4
	{-0.2067,	-0.16971,	-0.14671,	-0.1315,	-0.120916,	-0.11363,	-0.10444}, // e5
	{0.097533,	0.07983,	0.068808,	0.061603,	0.056538,	0.053178,	0.048551}, // e6
	{-0.011817,	-0.0094393,	-0.0079836,	-0.0070866,	-0.0064324,	-0.0060436,	-0.0053567}, // e7
	{0.0016145,	0.0012622,	0.0010535,	0.00092813,	0.00083723,	0.00077982,	0.00068809} }; // e8

double const et_low_table[4][7] = {
	{	-0.2061	,	-0.169279	,	-0.146377	,	-0.13121	,	-0.12067	,	-0.113399	,	-0.104243	}, //et5
	{	0.094449	,	0.077599	,	0.067052	,	0.060105	,	0.055232	,	0.051994	,	0.047573	}, //et6
	{	-0.0087953	,	-0.0071375	,	-0.0060951	,	-0.0054388	,	-0.004958	,	-0.0046876	,	-0.0041711	}, //et7
	{	0.00088385	,	0.00069025	,	0.00057456	,	0.00050585	,	0.00045512	,	0.00042548	,	0.00037068	} }; //et8

double const et_high_table[4][7] = {
	{-0.2061,	-0.169279,	-0.146377,	-0.13121,	-0.12067,	-0.113399,	-0.104243}, //et5
	{0.094449,	0.077599,	0.067052,	0.060105,	0.055232,	0.051994,	0.047573}, //et6
	{-0.0087953,	-0.0071375,	-0.0060951,	-0.0054388,	-0.004958,	-0.0046876,	-0.0041711}, //et7
	{0.00088385,	0.00069025,	0.00057456,	0.00050585,	0.00045512,	0.00042548,	0.00037068} }; //et8

double const l_low_table[6][7] = {
	{ 120,	120,	120,	120,	120,	120,	120 }, //lh
	{ -0.407768,	-0.902739,	-0.733037,	-1.31444,	-1.20026,	-1.52158,	-1.67664 }, //l0
	{ 0.00148506,	0.00826803,	0.00523396,	0.0133124,	0.0114087,	0.015704,	0.0177194 }, //l1
	{ 1.25357E-05,	-1.25448E-05,	6.35667E-06,	-2.55585E-05,	-1.47324E-05,	-3.02859E-05,	-3.69498E-05 }, //l2
	{ 3.77311E-08,	6.12853E-08,	1.09065E-08,	5.43981E-08,	2.7804E-08,	4.57668E-08,	5.09134E-08 }, //l3
	{ -7.78953E-11,	-7.07966E-11,	-2.61427E-11,	-4.33784E-11,	-2.2632E-11,	-2.82926E-11,	-2.82878E-11 } }; //l4

double const l_high_table[6][7] = {
	{640,	660,	740,	800,	860,	900,	900}, //lh
	{48.6536,	54.4867,	60.1267,	47.0996,	50.6174,	8.01942,	-15.5728}, //l0
	{-0.170291,	-0.178298,	-0.183144,	-0.12526,	-0.129047,	0.0185302,	0.0936704}, //l1
	{0.000226242,	0.000222725,	0.000212481,	0.000126352,	0.000124842,	-6.14733E-05,	-0.000149036}, //l2
	{-1.32032E-07,	-1.227E-07,	-1.08497E-07,	-5.51584E-08,	-5.24993E-08,	4.97674E-08,	9.42151E-08},  //l3
	{2.85193E-11,	2.51316E-11,	2.0571E-11,	8.75272E-12,	8.08272E-12,	-1.26162E-11,	-2.0961E-11} };  //l4

// Таблица 1
double const A[9] = { -2.53418e-02, -2.44075e-03, 3.08389e-06,
2.90115e-06, -4.99606e-08, 3.36327e-10,
-1.0966e-12, 1.73227e-15, -1.06271e-18 };

double F0_arr[7] = { 75.0, 100.0, 125.0, 150.0, 175.0, 200.0, 250.0 };

double calcF81(double const F107[81]) //значения F107 начиная с 80 суток перед текущей датой до текущей даты
{
	/* формула по расчёту F81 из ГОСТ */
	double num = 0.0; // числитель
	double denom = 0.0; // знаменатель
	for (int i = -80; i < 1; i++)
	{
		double Wi = 1.0 + (0.5 * i) / 80.0;
		num += F107[i + 80] * Wi;
		denom += Wi;
	}
	double F81 = num / denom;
	return F81;
}

/*
	[EN] Function atmosGOST_R_25645_166_2004() calculates uper Earth atmosphere density
	by russian GOST R 25645.166-2004 model. Returns density kg/m^3 if succeeded, -1 if failed.
	[RU] Функция atmosGOST_R_25645_166_2004() для расчёта плотности верхней земной атмосферы
	по модели из российского стандарта ГОСТ Р 25645.166-2004. В случае успешного расчёта возвращает
	плотность в кг/куб.м, или -1 в случае ошибки.
*/
double atmosGOST_R_25645_166_2004(double const h_km, // altitude above Earth ellipsoid, km; 120<h_km<1500
	double const F107, // F10.7 solar emission index / индекс солнечной активности
	double const Kp, // квазилогарифмический планетарный среднесуточный индекс геомагнитной активности, баллы
	double const F81, // averaged weighted F10.7 for previous 80 days + current day / усреднённый за 81 сутки (80 предыдущих + 1 текущие) и взвешенный индекс солнечной активности
	double const DoY, // number of day from the beginning of the year / номер суток от начала года //TODO заменить на Mjd_TT
	double const X[3], // x, y, z - geocentric greenwich coordinates, km / гринвичские координаты точи пространства, км
	double t_s, // всемирное время, с
	double S_rad, // sidereal midnight time, rad / звёздное время в гринвическую полночь, рад
	double alpha_rad, // right ascention of the Sun, rad / прямое восхождение Солнца, рад
	double delta_rad // declination of the Sun, rad / склонение Солнца, рад
)
// Выходной параметр - rho, кг/м^3 - плотность
{
	#ifdef PARAMETERS_CHECK_ON
	// 1. Проверка корректности ввода, незначительно замедляет производительность
	if (h_km < 120.0 || h_km > 1500.0) {
		std::cerr << "Input parameters Altitude above ellipsoid h_km = " << h_km
			<<"km, while h must be 120 km <= h <= 1500 km." << std::endl;
		return -1.0;
	}
	if (DoY < 0.0 || DoY > 366.0) {
		std::cerr << "Day of year DoY = " << DoY
			<< ", while h must be 0 <= DoY <= 366." << std::endl;
		return -1.0;
	}
	if (alpha_rad < 0.0 || alpha_rad > 2*M_PI) {
		std::cerr << "Right ascention alpha_rad = " << alpha_rad
			<< ", while alpha_rad must be 0 <= alpha_rad <= 2*PI." << std::endl;
		return -1.0;
	}
	if (delta_rad < -M_PI || delta_rad > M_PI) {
		std::cerr << "Declination delta_rad = " << delta_rad
			<< ", while delta_rad must be -PI <= delta_rad <= PI." << std::endl;
		return -1.0;
	}
	#endif // PARAMETERS_CHECK_ON

	// 2. Инициализация констант
	double const CONST_RHO_0 = 1.58868e-08; // кг / м ^ 3, плотность ночной атмосферы на высоте 120км
	double const CONST_OMEGA_Z = 7.292115e-05; // рад/с, угловая скорость вращения Земли
	// TODO учесть время запаздывания
	double const CONST_dt_f107 = 1.7; // запаздывание по F107
	double const CONST_dt_Kp = 0.6; // запаздывание по Kp
	double const CONST_dt_kpp = 0.25; // сут, запаздывание по kpp

	// 3. Предварительный расчёт степеней от h_km, DoY, Kp:
	// h_vec = {1, h, h^2, h^3, ..., h^6}
	double h_vec[7];
	h_vec[0] = 1.0;
	for (int i = 1; i < 7; i++)
	{
		h_vec[i] = h_vec[i - 1] * h_km;
	}

	// doy_vec = {1, DoY, DoY^2, DoY^3, ..., DoY^8}
	double doy_vec[9] = { 0.0 };
	doy_vec[0] = 1.0;
	for (int i = 1; i < 9; i++)
	{
		doy_vec[i] = doy_vec[i - 1] * DoY;
	}

	double Kp_vec[4] = { 0.0 };
	Kp_vec[0] = 1.0;
	for (int i = 1; i < 4; i++)
	{
		Kp_vec[i] = Kp_vec[i - 1] * Kp;
	}

	// 4. Выбор опорного значения индекса солнечной активности F0
	// и номера колонки для таблицы 2 или 3
	/*
	// альтернативный алгоритм поиска ближайшего  F0, показавший себя на 20-50% медленнее
	double F0 = 0.0;
	int n_col = 0.0;
	if (F81 <= 200.0 && F81 >= 75.0) {
		double tmp = round(F81 / 25.0);
		n_col = tmp - 3;
		F0 = tmp * 25.0;
	}
	else if (F81 <= 250.0 && F81 >= 200.0)
	{
		double tmp = round(F81 / 50.0);
		n_col = tmp + 1;
		F0 = tmp * 50.0;
	}
	else if (F81 < 75.0) {
		F0 = 75.0;
		n_col = 0;
	}
	else {
		F0 = round(F81 / 25) * 25.0;
		n_col = 6;
	} */

	int n_col = 0;
	double diff1 = abs(F0_arr[n_col] - F81);
	double diff2 = diff1;
	while (n_col < 6)
	{
		n_col++;
		diff2 = abs(F0_arr[n_col] - F81);
		if (diff1 <= diff2) {
			--n_col;
			break;
		}
		diff1 = diff2;
	}
	
	// 5. Выбор коэффициентов из таблиц, учитывая высоту (2 либо 3 таблицы ГОСТа)
	// в том порядке, в котором они приведены в таблицах 2-3
	double a[7] = { 0.0 };
	if (h_km < a_high_table[0][n_col]) {
		for (int i = 0; i < 7; i++)
		{
			a[i] = a_low_table[i + 1][n_col];
		}
	}
	else {
		for (int i = 0; i < 7; i++)
		{
			a[i] = a_high_table[i + 1][n_col];
		}
	}

	double b[5] = { 0.0 };
	if (h_km < b_high_table[0][n_col]) {
		for (int i = 0; i < 5; i++)
		{
			b[i] = b_low_table[i + 1][n_col];
		}
	}
	else {
		for (int i = 0; i < 5; i++)
		{
			b[i] = b_high_table[i + 1][n_col];
		}
	}

	double c[5] = { 0.0 };
	if (h_km < c_high_table[0][n_col]) {
		for (int i = 0; i < 5; i++)
		{
			c[i] = c_low_table[i + 1][n_col];
		}
	}
	else {
		for (int i = 0; i < 5; i++)
		{
			c[i] = c_high_table[i + 1][n_col];
		}
	}

	double n[3] = { 0.0 };
	if (h_km < c_high_table[0][n_col]) { // высота именно из таблицы коэффициента c
		for (int i = 0; i < 3; i++)
		{
			n[i] = n_low_table[i][n_col];
		}
	}
	else {
		for (int i = 0; i < 3; i++)
		{
			n[i] = n_high_table[i][n_col];
		}
	}

	// коэффициент модели, равный углу запаздывания максимума плотности по отношению к максимуму освещённости, рад
	double phi1 = 0.0;
	if (h_km <  c_high_table[0][n_col]) { // высота именно из таблицы коэффициента c
		phi1 = phi1_low_table[n_col];
	}
	else {
		phi1 = phi1_high_table[n_col];
	}

	double d[5] = { 0.0 };
	if (h_km < d_high_table[0][n_col]) {
		for (int i = 0; i < 5; i++)
		{
			d[i] = d_low_table[i + 1][n_col];
		}
	}
	else {
		for (int i = 0; i < 5; i++)
		{
			d[i] = d_high_table[i + 1][n_col];
		}
	}

	double e[9] = { 0.0 };
	if (h_km < e_high_table[0][n_col]) {
		for (int i = 0; i < 9; i++)
		{
			e[i] = e_low_table[i + 1][n_col];
		}
	}
	else {
		for (int i = 0; i < 9; i++)
		{
			e[i] = e_high_table[i + 1][n_col];
		}
	}

	double et[4] = { 0.0 };
	if (h_km < e_high_table[0][n_col]) { // высота именно из таблицы коэффициента e
		for (int i = 0; i < 4; i++)
		{
			et[i] = et_low_table[i][n_col];
		}
	}
	else {
		for (int i = 0; i < 4; i++)
		{
			et[i] = et_high_table[i][n_col];
		}
	}

	double l[5] = { 0.0 };
	if (h_km < l_high_table[0][n_col]) {
		for (int i = 0; i < 5; i++)
		{
			l[i] = l_low_table[i + 1][n_col];
		}
	}
	else {
		for (int i = 0; i < 5; i++)
		{
			l[i] = l_high_table[i + 1][n_col];
		}
	}

	// коэффициент K0, учитывающий изменение плотности атмосферы, связанное с отклонением
	double K0 = 0.0;
	for (int i = 0; i < 5; i++) // сборка полинома
	{
		K0 += l[i] * h_vec[i];
	};
	K0 = K0 * (F81 - F0_arr[n_col]) / F0_arr[n_col] + 1.0; // коэффициент в связи с отклонением F81 от F0

	// коффициент K1, учитывающий суточный эффект в распределении плотности
	double K1 = 0.0; // (c' * h_vec(1:5) ) * (cos_phi ^ ( n * h_vec(1:3) )) / 2; // суточный коэффициент распределения плотности
	for (int i = 0; i < 5; i++) // сборка полинома
	{
		K1 += c[i] * h_vec[i];
	};
	double cos_power = 0.0;
	for (int i = 0; i < 3; i++) // сборка полинома
	{
		cos_power += n[i] * h_vec[i];
	};

	double r = sqrt(X[0]* X[0] + X[1]*X[1] + X[2]*X[2]); // расстояние от центра гривничской СК

	// разность между долготой, для которой рассчитывают плотность атмосферы
	// и долготой с максимальным значением плотности в её суточном распределении, рад
	double beta_rad = alpha_rad - S_rad - CONST_OMEGA_Z * t_s + phi1;

	double cos_phi = 1 / r * (X[2] * sin(delta_rad)
		+ cos(delta_rad) * (X[0] * cos(beta_rad) + X[1] * sin(beta_rad)));
	K1 = K1 * pow(cos_phi, cos_power)/2;

	// коэффициент K2, учитывающий полугодовой эффект
	double K2 = 0.0;
	for (int i = 0; i < 5; i++) // сборка полинома
	{
		K2 += d[i] * h_vec[i];
	}
	double Ad = 0.0;
	for (int i = 0; i < 9; i++) // сборка полинома
	{
		Ad += A[i] * doy_vec[i]; // полугодовой коэффициент
	}
	K2 *= Ad;

	// коэффициент K3, учитывающий изменение плотности, связанное с отклонением F107 от F81
	double K3 = 0.0;
	for (int i = 0; i < 5; i++) // сборка полинома
	{
		K3 += b[i] * h_vec[i];
	}

	K3 *= (F107 - F81) / (F81 + abs(F107 - F81)); // изменение плотности в связи с отклонением F10.7 от F81

	// Расчёт коэффициента K4, учитывающий зависимость плотности атмосферы от геомагнитной возмущенности
	// при использовании среднесуточных коэффициентов геомагнитной активности
	// e[5]...e[8]  и  Kp, при использовании 3-х часовых - et[5]...et[8] и kpp
	double K4_1 = 0.0; // первый множитель K4
	for (int i = 0; i < 5; i++) // сборка полинома
	{
		K4_1 += e[i] * h_vec[i];
	}

	double K4_2 = 0.0; // второй множитель K4
	for (int i = 0; i < 4; i++) // сборка полинома
	{
		K4_2 += e[i+5] * Kp_vec[i];
	}

	double K4 = K4_1 * K4_2;

	// финальная формула
	double polynom = 0.0;
	for (int i = 0; i < 7; i++) // сборка полинома
	{
		polynom += a[i] * h_vec[i];
	}
	double rho_night = CONST_RHO_0 * exp(polynom);

	double rho = rho_night * K0 * (1 + K1 + K2 + K3 + K4);

	return rho;
}